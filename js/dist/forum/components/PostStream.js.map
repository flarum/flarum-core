{"version":3,"file":"forum/components/PostStream.js","mappings":"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","sources":["webpack://@flarum/core/./src/forum/components/ReplyPlaceholder.tsx","webpack://@flarum/core/./src/forum/components/PostType.tsx","webpack://@flarum/core/./src/forum/components/PostStream.js"],"sourcesContent":["import app from '../../forum/app';\nimport Component from '../../common/Component';\nimport username from '../../common/helpers/username';\nimport DiscussionControls from '../utils/DiscussionControls';\nimport ComposerPostPreview from './ComposerPostPreview';\nimport listItems from '../../common/helpers/listItems';\nimport Avatar from '../../common/components/Avatar';\n/**\n * The `ReplyPlaceholder` component displays a placeholder for a reply, which,\n * when clicked, opens the reply composer.\n */\nexport default class ReplyPlaceholder extends Component {\n  view() {\n    const composingReply = this.attrs.composingReply ? this.attrs.composingReply() : app.composer.composingReplyTo(this.attrs.discussion);\n    if (composingReply) {\n      return m(\"article\", {\n        className: \"Post CommentPost editing\",\n        \"aria-busy\": \"true\"\n      }, m(\"div\", {\n        className: \"Post-container\"\n      }, m(\"div\", {\n        className: \"Post-side\"\n      }, m(Avatar, {\n        user: app.session.user,\n        className: \"Post-avatar\"\n      })), m(\"div\", {\n        className: \"Post-main\"\n      }, m(\"header\", {\n        className: \"Post-header\"\n      }, m(\"div\", {\n        className: \"PostUser\"\n      }, m(\"h3\", {\n        className: \"PostUser-name\"\n      }, username(app.session.user)), m(\"ul\", {\n        className: \"PostUser-badges badges badges--packed\"\n      }, listItems(app.session.user.badges().toArray())))), m(\"div\", {\n        className: \"Post-body\"\n      }, m(ComposerPostPreview, {\n        className: \"Post-body\",\n        composer: app.composer,\n        surround: this.anchorPreview.bind(this)\n      })))));\n    }\n    const reply = this.attrs.onclick || (() => {\n      DiscussionControls.replyAction.call(this.attrs.discussion, true, false).catch(() => {});\n    });\n    return m(\"button\", {\n      type: \"button\",\n      className: \"Post ReplyPlaceholder\",\n      onclick: reply\n    }, m(\"div\", {\n      className: \"Post-container\"\n    }, m(\"div\", {\n      className: \"Post-side\"\n    }, m(Avatar, {\n      user: app.session.user,\n      className: \"Post-avatar\"\n    })), m(\"div\", {\n      className: \"Post-main\"\n    }, m(\"span\", {\n      className: \"Post-header\"\n    }, app.translator.trans('core.forum.post_stream.reply_placeholder')))));\n  }\n  anchorPreview(preview) {\n    const anchorToBottom = $(window).scrollTop() + $(window).height() >= $(document).height();\n    preview();\n    if (anchorToBottom) {\n      $(window).scrollTop($(document).height());\n    }\n  }\n}\nflarum.reg.add('core', 'forum/components/ReplyPlaceholder', ReplyPlaceholder);","import Component from '../../common/Component';\nimport app from '../app';\nexport default class PostType extends Component {\n  view() {\n    const post = this.attrs.post;\n    const PostComponent = app.postComponents[post.contentType()];\n    return !!PostComponent && m(PostComponent, {\n      post: post\n    });\n  }\n}\nflarum.reg.add('core', 'forum/components/PostType', PostType);","import app from '../../forum/app';\nimport Component from '../../common/Component';\nimport ScrollListener from '../../common/utils/ScrollListener';\nimport LoadingPost from './LoadingPost';\nimport ReplyPlaceholder from './ReplyPlaceholder';\nimport Button from '../../common/components/Button';\nimport ItemList from '../../common/utils/ItemList';\nimport PostType from './PostType';\n\n/**\n * The `PostStream` component displays an infinitely-scrollable wall of posts in\n * a discussion. Posts that have not loaded will be displayed as placeholders.\n *\n * ### Attrs\n *\n * - `discussion`\n * - `stream`\n * - `targetPost`\n * - `onPositionChange`\n */\nexport default class PostStream extends Component {\n  oninit(vnode) {\n    super.oninit(vnode);\n    this.discussion = this.attrs.discussion;\n    this.stream = this.attrs.stream;\n    this.scrollListener = new ScrollListener(this.onscroll.bind(this));\n  }\n  view() {\n    let lastTime;\n    const viewingEnd = this.stream.viewingEnd();\n    const posts = this.stream.posts();\n    const postIds = this.discussion.postIds();\n    const postFadeIn = vnode => {\n      $(vnode.dom).addClass('fadeIn');\n      // 500 is the duration of the fadeIn CSS animation + 100ms,\n      // so the animation has time to complete\n      setTimeout(() => $(vnode.dom).removeClass('fadeIn'), 500);\n    };\n    const items = posts.map((post, i) => {\n      let content;\n      const attrs = {\n        'data-index': this.stream.visibleStart + i\n      };\n      if (post) {\n        const time = post.createdAt();\n        content = m(PostType, {\n          post: post\n        });\n        attrs.key = 'post' + post.id();\n        attrs.oncreate = postFadeIn;\n        attrs['data-time'] = time.toISOString();\n        attrs['data-number'] = post.number();\n        attrs['data-id'] = post.id();\n        attrs['data-type'] = post.contentType();\n\n        // If the post before this one was more than 4 days ago, we will\n        // display a 'time gap' indicating how long it has been in between\n        // the posts.\n        const dt = time - lastTime;\n        if (dt > 1000 * 60 * 60 * 24 * 4) {\n          content = [m(\"div\", {\n            className: \"PostStream-timeGap\"\n          }, m(\"span\", null, app.translator.trans('core.forum.post_stream.time_lapsed_text', {\n            period: dayjs().add(dt, 'ms').fromNow(true)\n          }))), content];\n        }\n        lastTime = time;\n      } else {\n        attrs.key = 'post' + postIds[this.stream.visibleStart + i];\n        content = m(LoadingPost, null);\n      }\n      const postStreamElement = m(\"div\", Object.assign({\n        className: \"PostStream-item\"\n      }, attrs), content);\n      const afterPostItems = post && post.id() === this.discussion.data.relationships.firstPost?.data.id ? this.afterFirstPostItems().toArray() : [];\n      if (afterPostItems.length > 0) {\n        return m.fragment({\n          ...attrs\n        }, [postStreamElement, m(\"div\", {\n          className: \"PostStream-item PostStream-afterFirstPost\",\n          key: \"afterFirstPost\"\n        }, afterPostItems)]);\n      }\n      return postStreamElement;\n    });\n    if (!viewingEnd && posts[this.stream.visibleEnd - this.stream.visibleStart - 1]) {\n      items.push(m(\"div\", {\n        className: \"PostStream-loadMore\",\n        key: \"loadMore\"\n      }, m(Button, {\n        className: \"Button\",\n        onclick: this.stream.loadNext.bind(this.stream)\n      }, app.translator.trans('core.forum.post_stream.load_more_button'))));\n    }\n\n    // Allow extensions to add items to the end of the post stream.\n    if (viewingEnd) {\n      items.push(...this.endItems().toArray());\n    }\n\n    // If we're viewing the end of the discussion, the user can reply, and\n    // is not already doing so, then show a 'write a reply' placeholder.\n    if (viewingEnd && (!app.session.user || this.discussion.canReply())) {\n      items.push(m(\"div\", {\n        className: \"PostStream-item\",\n        key: \"reply\",\n        \"data-index\": this.stream.count(),\n        oncreate: postFadeIn\n      }, m(ReplyPlaceholder, {\n        discussion: this.discussion\n      })));\n    }\n    return m(\"div\", {\n      className: \"PostStream\",\n      role: \"feed\",\n      \"aria-live\": \"off\",\n      \"aria-busy\": this.stream.pagesLoading ? 'true' : 'false'\n    }, items);\n  }\n\n  /**\n   * @returns {ItemList<import('mithril').Children>}\n   */\n  afterFirstPostItems() {\n    const items = new ItemList();\n    return items;\n  }\n\n  /**\n   * @returns {ItemList<import('mithril').Children>}\n   */\n  endItems() {\n    const items = new ItemList();\n    return items;\n  }\n  onupdate(vnode) {\n    super.onupdate(vnode);\n    this.triggerScroll();\n  }\n  oncreate(vnode) {\n    super.oncreate(vnode);\n    this.triggerScroll();\n\n    // This is wrapped in setTimeout due to the following Mithril issue:\n    // https://github.com/lhorie/mithril.js/issues/637\n    setTimeout(() => this.scrollListener.start());\n  }\n  onremove(vnode) {\n    super.onremove(vnode);\n    this.scrollListener.stop();\n    clearTimeout(this.calculatePositionTimeout);\n  }\n\n  /**\n   * Start scrolling, if appropriate, to a newly-targeted post.\n   */\n  triggerScroll() {\n    if (!this.stream.needsScroll) return;\n    const target = this.stream.targetPost;\n    this.stream.needsScroll = false;\n    if ('number' in target) {\n      this.scrollToNumber(target.number, this.stream.animateScroll);\n    } else if ('index' in target) {\n      this.scrollToIndex(target.index, this.stream.animateScroll, target.reply);\n    }\n  }\n\n  /**\n   *\n   * @param {number} top\n   */\n  onscroll(top) {\n    if (top === void 0) {\n      top = window.pageYOffset;\n    }\n    if (this.stream.paused || this.stream.pagesLoading) return;\n    this.updateScrubber(top);\n    this.loadPostsIfNeeded(top);\n\n    // Throttle calculation of our position (start/end numbers of posts in the\n    // viewport) to 100ms.\n    clearTimeout(this.calculatePositionTimeout);\n    this.calculatePositionTimeout = setTimeout(this.calculatePosition.bind(this, top), 100);\n  }\n\n  /**\n   * Check if either extreme of the post stream is in the viewport,\n   * and if so, trigger loading the next/previous page.\n   *\n   * @param {number} top\n   */\n  loadPostsIfNeeded(top) {\n    if (top === void 0) {\n      top = window.pageYOffset;\n    }\n    const marginTop = this.getMarginTop();\n    const viewportHeight = $(window).height() - marginTop;\n    const viewportTop = top + marginTop;\n    const loadAheadDistance = 300;\n    if (this.stream.visibleStart > 0) {\n      const $item = this.$('.PostStream-item[data-index=' + this.stream.visibleStart + ']');\n      if ($item.length && $item.offset().top > viewportTop - loadAheadDistance) {\n        this.stream.loadPrevious();\n      }\n    }\n    if (this.stream.visibleEnd < this.stream.count()) {\n      const $item = this.$('.PostStream-item[data-index=' + (this.stream.visibleEnd - 1) + ']');\n      if ($item.length && $item.offset().top + $item.outerHeight(true) < viewportTop + viewportHeight + loadAheadDistance) {\n        this.stream.loadNext();\n      }\n    }\n  }\n  updateScrubber(top) {\n    if (top === void 0) {\n      top = window.pageYOffset;\n    }\n    const marginTop = this.getMarginTop();\n    const viewportHeight = $(window).height() - marginTop;\n    const viewportTop = top + marginTop;\n\n    // Before looping through all of the posts, we reset the scrollbar\n    // properties to a 'default' state. These values reflect what would be\n    // seen if the browser were scrolled right up to the top of the page,\n    // and the viewport had a height of 0.\n    const $items = this.$('.PostStream-item[data-index]');\n    let visible = 0;\n    let period = '';\n    let indexFromViewPort = null;\n\n    // Now loop through each of the items in the discussion. An 'item' is\n    // either a single post or a 'gap' of one or more posts that haven't\n    // been loaded yet.\n    $items.each(function () {\n      const $this = $(this);\n      const top = $this.offset().top;\n      const height = $this.outerHeight(true);\n\n      // If this item is above the top of the viewport, skip to the next\n      // one. If it's below the bottom of the viewport, break out of the\n      // loop.\n      if (top + height < viewportTop) {\n        return true;\n      }\n      if (top > viewportTop + viewportHeight) {\n        return false;\n      }\n\n      // Work out how many pixels of this item are visible inside the viewport.\n      // Then add the proportion of this item's total height to the index.\n      const visibleTop = Math.max(0, viewportTop - top);\n      const visibleBottom = Math.min(height, viewportTop + viewportHeight - top);\n      const visiblePost = visibleBottom - visibleTop;\n\n      // We take the index of the first item that passed the previous checks.\n      // It is the item that is first visible in the viewport.\n      if (indexFromViewPort === null) {\n        indexFromViewPort = parseFloat($this.data('index')) + visibleTop / height;\n      }\n      if (visiblePost > 0) {\n        visible += visiblePost / height;\n      }\n\n      // If this item has a time associated with it, then set the\n      // scrollbar's current period to a formatted version of this time.\n      const time = $this.data('time');\n      if (time) period = time;\n    });\n\n    // If indexFromViewPort is null, it means no posts are visible in the\n    // viewport. This can happen, when drafting a long reply post. In that case\n    // set the index to the last post.\n    this.stream.index = indexFromViewPort !== null ? indexFromViewPort + 1 : this.stream.count();\n    this.stream.visible = visible;\n    if (period) this.stream.description = app.translator.formatDateTime(dayjs(period), 'core.lib.datetime_formats.scrubber');\n  }\n\n  /**\n   * Work out which posts (by number) are currently visible in the viewport, and\n   * fire an event with the information.\n   */\n  calculatePosition(top) {\n    if (top === void 0) {\n      top = window.pageYOffset;\n    }\n    const marginTop = this.getMarginTop();\n    const $window = $(window);\n    const viewportHeight = $window.height() - marginTop;\n    const scrollTop = $window.scrollTop() + marginTop;\n    const viewportTop = top + marginTop;\n    let startNumber;\n    let endNumber;\n    this.$('.PostStream-item').each(function () {\n      const $item = $(this);\n      const top = $item.offset().top;\n      const height = $item.outerHeight(true);\n      const visibleTop = Math.max(0, viewportTop - top);\n      const threeQuartersVisible = visibleTop / height < 0.75;\n      const coversQuarterOfViewport = (height - visibleTop) / viewportHeight > 0.25;\n      if (startNumber === undefined && (threeQuartersVisible || coversQuarterOfViewport)) {\n        startNumber = $item.data('number');\n      }\n      if (top + height > scrollTop) {\n        if (top + height < scrollTop + viewportHeight) {\n          if ($item.data('number')) {\n            endNumber = $item.data('number');\n          }\n        } else return false;\n      }\n    });\n    if (startNumber) {\n      this.attrs.onPositionChange(startNumber || 1, endNumber, startNumber);\n    }\n  }\n\n  /**\n   * Get the distance from the top of the viewport to the point at which we\n   * would consider a post to be the first one visible.\n   *\n   * @return {number}\n   */\n  getMarginTop() {\n    const headerId = app.screen() === 'phone' ? '#app-navigation' : '#header';\n    return this.$() && $(headerId).outerHeight() + parseInt(this.$().css('margin-top'), 10);\n  }\n\n  /**\n   * Scroll down to a certain post by number and 'flash' it.\n   *\n   * @param {number} number\n   * @param {boolean} animate\n   * @return {JQueryDeferred}\n   */\n  scrollToNumber(number, animate) {\n    const $item = this.$(`.PostStream-item[data-number=${number}]`);\n    return this.scrollToItem($item, animate).then(this.flashItem.bind(this, $item));\n  }\n\n  /**\n   * Scroll down to a certain post by index.\n   *\n   * @param {number} index\n   * @param {boolean} animate\n   * @param {boolean} reply Whether or not to scroll to the reply placeholder.\n   * @return {JQueryDeferred}\n   */\n  scrollToIndex(index, animate, reply) {\n    const $item = reply ? $('.PostStream-item:last-child') : this.$(`.PostStream-item[data-index=${index}]`);\n    this.scrollToItem($item, animate, true, reply);\n    if (reply) {\n      this.flashItem($item);\n    }\n  }\n\n  /**\n   * Scroll down to the given post.\n   *\n   * @param {JQuery} $item\n   * @param {boolean} animate\n   * @param {boolean} force Whether or not to force scrolling to the item, even\n   *     if it is already in the viewport.\n   * @param {boolean} reply Whether or not to scroll to the reply placeholder.\n   * @return {JQueryDeferred}\n   */\n  scrollToItem($item, animate, force, reply) {\n    const $container = $('html, body').stop(true);\n    const index = $item.data('index');\n    if ($item.length) {\n      const itemTop = $item.offset().top - this.getMarginTop();\n      const itemBottom = $item.offset().top + $item.height();\n      const scrollTop = $(document).scrollTop();\n      const scrollBottom = scrollTop + $(window).height();\n\n      // If the item is already in the viewport, we may not need to scroll.\n      // If we're scrolling to the reply placeholder, we'll make sure its\n      // bottom will line up with the top of the composer.\n      if (force || itemTop < scrollTop || itemBottom > scrollBottom) {\n        const top = reply ? itemBottom - $(window).height() + app.composer.computedHeight() : $item.is(':first-child') ? 0 : itemTop;\n        if (!animate) {\n          $container.scrollTop(top);\n        } else if (top !== scrollTop) {\n          $container.animate({\n            scrollTop: top\n          }, 'fast');\n        }\n      }\n    }\n    const updateScrubberHeight = () => {\n      // We manually set the index because we want to display the index of the\n      // exact post we've scrolled to, not just that of the first post within viewport.\n      this.updateScrubber();\n      if (index !== undefined) this.stream.index = index + 1;\n    };\n\n    // If we don't update this before the scroll, the scrubber will start\n    // at the top, and animate down, which can be confusing\n    updateScrubberHeight();\n    this.stream.forceUpdateScrubber = true;\n    return Promise.all([$container.promise(), this.stream.loadPromise]).then(() => {\n      m.redraw.sync();\n\n      // Rendering post contents will probably throw off our position.\n      // To counter this, we'll scroll either:\n      //   - To the reply placeholder (aligned with composer top)\n      //   - To the top of the page if we're on the first post\n      //   - To the top of a post (if that post exists)\n      // If the post does not currently exist, it's probably\n      // outside of the range we loaded in, so we won't adjust anything,\n      // as it will soon be rendered by the \"load more\" system.\n      let itemOffset;\n      if (reply) {\n        const $placeholder = $('.PostStream-item:last-child');\n        $(window).scrollTop($placeholder.offset().top + $placeholder.height() - $(window).height() + app.composer.computedHeight());\n      } else if (index === 0) {\n        $(window).scrollTop(0);\n      } else if (itemOffset = $(`.PostStream-item[data-index=${index}]`).offset()) {\n        $(window).scrollTop(itemOffset.top - this.getMarginTop());\n      }\n\n      // We want to adjust this again after posts have been loaded in\n      // and position adjusted so that the scrubber's height is accurate.\n      updateScrubberHeight();\n      this.calculatePosition();\n      this.stream.paused = false;\n      // Check if we need to load more posts after scrolling.\n      this.loadPostsIfNeeded();\n    });\n  }\n\n  /**\n   * 'Flash' the given post, drawing the user's attention to it.\n   *\n   * @param {JQuery} $item\n   */\n  flashItem($item) {\n    // This might execute before the fadeIn class has been removed in PostStreamItem's\n    // oncreate, so we remove it just to be safe and avoid a double animation.\n    $item.removeClass('fadeIn');\n    $item.addClass('flash').on('animationend webkitAnimationEnd', e => {\n      $item.removeClass('flash');\n    });\n  }\n}\nflarum.reg.add('core', 'forum/components/PostStream', PostStream);"],"names":["ReplyPlaceholder","Component","view","this","attrs","composingReply","app","composer","composingReplyTo","discussion","m","className","Avatar","A","user","session","username","listItems","badges","toArray","ComposerPostPreview","surround","anchorPreview","bind","reply","onclick","DiscussionControls","replyAction","call","catch","type","translator","trans","preview","anchorToBottom","$","window","scrollTop","height","document","flarum","reg","add","PostType","post","PostComponent","postComponents","contentType","PostStream","oninit","vnode","super","stream","scrollListener","ScrollListener","onscroll","lastTime","viewingEnd","posts","postIds","postFadeIn","dom","addClass","setTimeout","removeClass","items","map","i","content","visibleStart","time","createdAt","key","id","oncreate","toISOString","number","dt","period","dayjs","fromNow","LoadingPost","postStreamElement","Object","assign","afterPostItems","data","relationships","firstPost","afterFirstPostItems","length","fragment","visibleEnd","push","Button","loadNext","endItems","canReply","count","role","pagesLoading","ItemList","onupdate","triggerScroll","start","onremove","stop","clearTimeout","calculatePositionTimeout","needsScroll","target","targetPost","scrollToNumber","animateScroll","scrollToIndex","index","top","pageYOffset","paused","updateScrubber","loadPostsIfNeeded","calculatePosition","marginTop","getMarginTop","viewportHeight","viewportTop","$item","offset","loadPrevious","outerHeight","$items","visible","indexFromViewPort","each","$this","visibleTop","Math","max","visiblePost","min","parseFloat","description","formatDateTime","$window","startNumber","endNumber","undefined","onPositionChange","headerId","screen","parseInt","css","animate","scrollToItem","then","flashItem","force","$container","itemTop","itemBottom","scrollBottom","computedHeight","is","updateScrubberHeight","forceUpdateScrubber","Promise","all","promise","loadPromise","itemOffset","redraw","sync","$placeholder","on","e"],"sourceRoot":""}